rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /* ---------- Helpers ---------- */
    function isSignedIn() { return request.auth != null; }
    function uid() { return request.auth.uid; }

    // Anything under users/{userId}/... is private to that userId
    function isPathOwner(userId) {
      return isSignedIn() && userId == uid();
    }

    // Does the current user own the trip?
    function isTripOwner(tripId) {
      return isSignedIn()
        && exists(/databases/$(database)/documents/trips/$(tripId))
        && get(/databases/$(database)/documents/trips/$(tripId)).data.userId == uid();
    }

    function isAdmin() {
      return isSignedIn()
        && exists(/databases/$(database)/documents/users/$(uid()))
        && get(/databases/$(database)/documents/users/$(uid())).data.role == "admin";
    }

    /* =====================================================
       1) Bag Checklist & User profile docs: users/{uid}/...
    ===================================================== */
    match /users/{userId} {
      allow get: if isPathOwner(userId) || (isAdmin() && userId != uid());
      allow list: if isAdmin();
      allow create: if isPathOwner(userId);
      allow update: if isPathOwner(userId);
      allow delete: if false;

      match /checklists/{listId} {
        allow read, write: if isPathOwner(userId);
      }
      match /checklists/{listId}/categories/{categoryId} {
        allow read, write: if isPathOwner(userId);
      }
      match /checklists/{listId}/categories/{categoryId}/items/{itemId} {
        allow read, write: if isPathOwner(userId);
      }
      match /checklists/{listId}/tasks/{taskId} {
        allow read, write: if isPathOwner(userId);
      }
    }

    /* =====================================================
       2) Trips (per-user private): /trips/{tripId}
    ===================================================== */
    match /trips/{tripId} {
      // Create: must set userId to caller's UID
      allow create: if isSignedIn()
        && request.resource.data.userId is string
        && request.resource.data.userId == uid();

      // Read/Delete: only the trip owner
      allow read, delete: if isSignedIn()
        && resource.data.userId == uid();

      // Update: only owner; userId immutable
      allow update: if isSignedIn()
        && resource.data.userId == uid()
        && request.resource.data.userId == resource.data.userId;
    }

    /* =====================================================
       3) Itinerary items: /itinerary/{itemId}
          Each item has tripId; only owner of that trip can access.
    ===================================================== */
    match /itinerary/{itemId} {
      // Create: must include tripId the caller owns
      allow create: if isSignedIn()
        && request.resource.data.tripId is string
        && isTripOwner(request.resource.data.tripId);

      // Read/Delete: only if caller owns linked trip
      allow read, delete: if isSignedIn()
        && resource.data.tripId is string
        && isTripOwner(resource.data.tripId);

      // Update: owner of linked trip; tripId immutable
      allow update: if isSignedIn()
        && resource.data.tripId is string
        && isTripOwner(resource.data.tripId)
        && request.resource.data.tripId == resource.data.tripId;
    }

    /* =====================================================
       4) Expenses: /expenses/{expenseId}
          Per-user private; tied to a trip the user owns.
    ===================================================== */
    match /expenses/{expenseId} {

      // ── Validators ──
      function validExpenseCreate() {
        return
          request.resource.data.keys().hasAll([
            'description', 'amount', 'category', 'timestamp', 'tripId', 'userId'
          ]) &&
          request.resource.data.userId is string &&
          request.resource.data.userId == uid() &&
          request.resource.data.tripId is string &&
          isTripOwner(request.resource.data.tripId) &&
          (request.resource.data.timestamp is number || request.resource.data.timestamp is timestamp) &&
          request.resource.data.amount is number &&
          request.resource.data.amount > 0 &&
          request.resource.data.description is string &&
          request.resource.data.category is string;
      }

      function validExpenseUpdate() {
        return
          resource.data.userId == uid() &&
          request.resource.data.userId == resource.data.userId &&
          request.resource.data.tripId == resource.data.tripId &&
          isTripOwner(resource.data.tripId) &&
          (request.resource.data.timestamp is number || request.resource.data.timestamp is timestamp) &&
          request.resource.data.amount is number &&
          request.resource.data.amount > 0 &&
          request.resource.data.description is string &&
          request.resource.data.category is string;
      }

      // ── Rules ──
      allow create: if isSignedIn() && validExpenseCreate();

      allow read: if isSignedIn()
        && resource.data.userId == uid()
        && resource.data.tripId is string
        && isTripOwner(resource.data.tripId);

      allow update: if isSignedIn() && validExpenseUpdate();

      allow delete: if isSignedIn()
        && resource.data.userId == uid()
        && isTripOwner(resource.data.tripId);
    }

    /* =====================================================
       5) Reviews (SIGNED-IN USERS): /reviews/{reviewId}
          Only signed-in users can read/write
    ===================================================== */
    match /reviews/{reviewId} {
      // Only signed-in users can read
      allow read: if request.auth != null;

      // Only the signed-in author can create
      allow create: if request.auth != null
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.username is string
        && request.resource.data.locationName is string
        && request.resource.data.locationNameFold is string
        && request.resource.data.tripDate is timestamp
        && request.resource.data.rating is int
        && request.resource.data.rating >= 1 && request.resource.data.rating <= 5
        && request.resource.data.comment is string
        && request.resource.data.createdAt is timestamp
        && request.resource.data.updatedAt is timestamp;

      // Allow author to update their own review OR allow any user to update reportCount/updatedAt (for reporting)
      allow update: if request.auth != null
        && (
          // Author updating their own review
          (resource.data.userId == request.auth.uid && request.resource.data.userId == request.auth.uid)
          ||
          // OR: Any authenticated user can update reportCount and updatedAt (for reporting feature)
          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reportCount', 'updatedAt']))
        );

      // Allow users to delete their own reviews OR allow deletion of reported reviews (for admin moderation)
      allow delete: if request.auth != null 
        && (
          // User deleting their own review
          resource.data.userId == request.auth.uid
          ||
          // OR: Any authenticated user can delete a review that has been reported (reportCount > 0)
          // This allows admins to delete reported reviews
          (resource.data.reportCount is int && resource.data.reportCount > 0)
        );

      // Reports subcollection - allow authenticated users to create and read reports
      match /reports/{reportId} {
        allow read: if request.auth != null;
        allow create: if request.auth != null
          && request.resource.data.userId == request.auth.uid;
        allow update, delete: if false; // Reports are immutable
      }
    }

    /* =====================================================
       6) Packing Categories (PRIVATE): users/{uid}/packingCategories/...
    ===================================================== */
    match /users/{userId}/packingCategories/{categoryId} {
      allow read, write: if isPathOwner(userId);
    }

    /* =====================================================
       7) Packing Items (PRIVATE): users/{uid}/packingItems/...
    ===================================================== */
    match /users/{userId}/packingItems/{itemId} {
      allow read, write: if isPathOwner(userId);
    }
  }
}
